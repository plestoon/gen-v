// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.32.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'simple.freezed.dart';

// The type `CertFiles` is not used by any `pub` functions, thus it is ignored.
// The type `CertPair` is not used by any `pub` functions, thus it is ignored.

Future<CertPairPem> genServerCert(
        {required List<Rdn> subject,
        required List<String> subjectAltNames,
        required KeyCipher keyCipher,
        required int validity,
        CertPairPem? issuer,
        dynamic hint}) =>
    RustLib.instance.api.genServerCert(
        subject: subject,
        subjectAltNames: subjectAltNames,
        keyCipher: keyCipher,
        validity: validity,
        issuer: issuer,
        hint: hint);

Future<CertPairPem> genClientCert(
        {required List<Rdn> subject,
        required KeyCipher keyCipher,
        required int validity,
        CertPairPem? issuer,
        dynamic hint}) =>
    RustLib.instance.api.genClientCert(
        subject: subject,
        keyCipher: keyCipher,
        validity: validity,
        issuer: issuer,
        hint: hint);

Future<CertPairPem> genRootCaCert(
        {required List<Rdn> subject,
        required KeyCipher keyCipher,
        required int validity,
        dynamic hint}) =>
    RustLib.instance.api.genRootCaCert(
        subject: subject, keyCipher: keyCipher, validity: validity, hint: hint);

Future<CertPairPem> genSubCaCert(
        {required List<Rdn> subject,
        required KeyCipher keyCipher,
        required int validity,
        required CertPairPem issuer,
        dynamic hint}) =>
    RustLib.instance.api.genSubCaCert(
        subject: subject,
        keyCipher: keyCipher,
        validity: validity,
        issuer: issuer,
        hint: hint);

class CertPairPem {
  final String chain;
  final String key;

  const CertPairPem({
    required this.chain,
    required this.key,
  });

  @override
  int get hashCode => chain.hashCode ^ key.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CertPairPem &&
          runtimeType == other.runtimeType &&
          chain == other.chain &&
          key == other.key;
}

enum EcdsaCurve {
  p224,
  p256,
  p384,
  ;
}

@freezed
sealed class KeyCipher with _$KeyCipher {
  const KeyCipher._();

  const factory KeyCipher.rsa(
    int field0,
  ) = KeyCipher_Rsa;
  const factory KeyCipher.ecdsa(
    EcdsaCurve field0,
  ) = KeyCipher_Ecdsa;
}

class Rdn {
  final RdnType rdnType;
  final String value;

  const Rdn({
    required this.rdnType,
    required this.value,
  });

  @override
  int get hashCode => rdnType.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Rdn &&
          runtimeType == other.runtimeType &&
          rdnType == other.rdnType &&
          value == other.value;
}

enum RdnType {
  commonName,
  countryName,
  stateOrProvinceName,
  localityName,
  organizationName,
  organizationalUnitName,
  ;
}
