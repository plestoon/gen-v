// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.28.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'simple.freezed.dart';

Future<CertData> genTlsCert(
        {required CertProfile certProfile,
        List<String>? domainNames,
        required List<SubjectRdn> subject,
        required Issuer issuer,
        required Cipher cipher,
        required int validity,
        required KeyFormat format,
        dynamic hint}) =>
    RustLib.instance.api.genTlsCert(
        certProfile: certProfile,
        domainNames: domainNames,
        subject: subject,
        issuer: issuer,
        cipher: cipher,
        validity: validity,
        format: format,
        hint: hint);

class CertData {
  final Uint8List cert;
  final Uint8List key;

  const CertData({
    required this.cert,
    required this.key,
  });

  @override
  int get hashCode => cert.hashCode ^ key.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CertData &&
          runtimeType == other.runtimeType &&
          cert == other.cert &&
          key == other.key;
}

class CertFiles {
  final String certPath;
  final String keyPath;

  const CertFiles({
    required this.certPath,
    required this.keyPath,
  });

  @override
  int get hashCode => certPath.hashCode ^ keyPath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CertFiles &&
          runtimeType == other.runtimeType &&
          certPath == other.certPath &&
          keyPath == other.keyPath;
}

enum CertProfile {
  client,
  server,
  rootCa,
  subCa,
}

@freezed
sealed class Cipher with _$Cipher {
  const factory Cipher.rsa(
    int field0,
  ) = Cipher_Rsa;
  const factory Cipher.ecdsa(
    EcdsaCurve field0,
  ) = Cipher_Ecdsa;
}

enum EcdsaCurve {
  p224,
  p256,
  p384,
}

@freezed
sealed class Issuer with _$Issuer {
  const factory Issuer.certSelf() = Issuer_CertSelf;
  const factory Issuer.ca(
    CertFiles field0,
  ) = Issuer_CA;
}

enum KeyFormat {
  pem,
  der,
}

class SubjectRdn {
  final String name;
  final String value;

  const SubjectRdn({
    required this.name,
    required this.value,
  });

  @override
  int get hashCode => name.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SubjectRdn &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          value == other.value;
}
